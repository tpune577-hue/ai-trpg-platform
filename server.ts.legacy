import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
import { Server } from 'socket.io'
import { PrismaClient } from '@prisma/client'
// import à¹à¸šà¸šà¸™à¸µà¹‰à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸ªà¸³à¸«à¸£à¸±à¸šà¹„à¸Ÿà¸¥à¹Œ ai-game-master.ts à¸‚à¸­à¸‡à¸„à¸¸à¸“
import { processGameTurn, type GameMasterResponse } from './lib/ai-game-master'

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()
const prisma = new PrismaClient()

// Helper: à¹à¸›à¸¥à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸ DB (String) à¹ƒà¸«à¹‰à¹€à¸›à¹‡à¸™ Object
const parseJSON = (data: any) => {
    if (typeof data === 'string') {
        try { return JSON.parse(data) } catch (e) { return {} }
    }
    return data || {}
}

app.prepare().then(() => {
    const httpServer = createServer((req, res) => {
        const parsedUrl = parse(req.url!, true)
        handle(req, res, parsedUrl)
    })

    const io = new Server(httpServer, {
        cors: { origin: '*', methods: ['GET', 'POST'] }
    })

    // Middleware: à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ªà¸´à¸—à¸˜à¸´à¹Œ (à¸£à¸­à¸‡à¸£à¸±à¸š Demo Token)
    io.use(async (socket, next) => {
        const token = socket.handshake.auth.sessionToken
        const campaignId = socket.handshake.auth.campaignId

        try {
            let user = null

            // ðŸ”“ à¸—à¸²à¸‡à¸¥à¸±à¸”à¸ªà¸³à¸«à¸£à¸±à¸š DEMO
            if (token === 'DEMO_GM_TOKEN') {
                user = await prisma.user.findUnique({ where: { email: 'gm@ai-trpg.com' } })
            } else if (token === 'DEMO_PLAYER_TOKEN') {
                user = await prisma.user.findUnique({ where: { email: 'demo@ai-trpg.com' } })
            } else if (token) {
                // à¸à¸£à¸“à¸µà¸¡à¸µ Token à¸­à¸·à¹ˆà¸™à¹† (à¹€à¸œà¸·à¹ˆà¸­à¸­à¸™à¸²à¸„à¸•)
                user = await prisma.user.findFirst({ where: { id: token } })
            }

            // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µ User (à¸«à¸£à¸·à¸­à¸«à¸²à¹„à¸¡à¹ˆà¹€à¸ˆà¸­)
            if (!user) {
                // Bypass à¹à¸šà¸šà¸ªà¸¸à¸”à¹† à¸–à¹‰à¸²à¸«à¸²à¹„à¸¡à¹ˆà¹€à¸ˆà¸­à¸ˆà¸£à¸´à¸‡à¹† à¹ƒà¸«à¹‰à¹€à¸›à¹‡à¸™ Guest (à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰ Demo à¸£à¸±à¸™à¸œà¹ˆà¸²à¸™)
                console.log('âš ï¸ Auth warning: User not found, creating temporary session')
                socket.data.user = { id: 'guest', name: 'Guest', role: 'PLAYER' }
            } else {
                socket.data.user = user
            }

            socket.data.campaignId = campaignId
            next()
        } catch (error) {
            console.error('Auth Error:', error)
            next(new Error('Authentication failed'))
        }
    })

    io.on('connection', (socket) => {
        console.log(`ðŸ‘¤ User connected: ${socket.data.user.name}`)

        // à¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡à¸«à¹‰à¸­à¸‡
        socket.on('join_room', async ({ campaignId }) => {
            socket.join(campaignId)
            console.log(`ðŸ  Joined room: ${campaignId}`)

            try {
                const campaign = await prisma.campaign.findUnique({
                    where: { id: campaignId }
                })

                if (campaign) {
                    // à¸ªà¹ˆà¸‡ State à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
                    const currentState = parseJSON(campaign.currentState)
                    socket.emit('game:state_update', currentState)

                    // --- NEW API: Room Presence ---
                    const sockets = await io.in(campaignId).fetchSockets()
                    const connectedPlayers = sockets.map(s => ({
                        id: s.data.user.id,
                        name: s.data.user.name,
                        role: s.data.user.role,
                        characterId: s.data.user.characterId // à¸–à¹‰à¸²à¸¡à¸µ
                    }))

                    // 1. Tell Me: Room Info
                    socket.emit('room:joined', {
                        roomInfo: {
                            roomId: campaignId,
                            campaignTitle: campaign.title,
                            connectedPlayers: connectedPlayers,
                            gmId: campaign.gmId
                        },
                        userProfile: socket.data.user
                    })

                    // 2. Tell Others: I joined
                    socket.to(campaignId).emit('room:player_joined', {
                        userProfile: socket.data.user
                    })
                }
            } catch (e) {
                console.error("Error fetching campaign:", e)
            }
        })

        // à¸£à¸±à¸š Action à¸ˆà¸²à¸à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™
        socket.on('player_action', async (data) => {
            const { campaignId, action } = data
            console.log(`âš”ï¸ Action received:`, action)

            // à¹à¸ˆà¹‰à¸‡à¸—à¸¸à¸à¸„à¸™à¹ƒà¸™à¸«à¹‰à¸­à¸‡à¸§à¹ˆà¸²à¸¡à¸µ Action à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™
            io.to(campaignId).emit('game:action', {
                player: socket.data.user.name,
                action: action
            })

            // à¹ƒà¸«à¹‰ AI à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥
            await processActionWithAI(io, campaignId, action, socket.data.user)
        })

        // --- GM Controls ---

        // 1. GM: Set Private Scene
        socket.on('gm:set_private_scene', async (data) => {
            const { playerId, sceneId } = data
            const campaignId = socket.data.campaignId

            // Auth Check: à¸„à¸§à¸£à¹€à¸Šà¹‡à¸„à¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ GM à¸‚à¸­à¸‡ Campaign à¸™à¸µà¹‰à¸ˆà¸£à¸´à¸‡à¹†
            if (socket.data.user.role !== 'GM' && socket.data.user.role !== 'CREATOR') return

            console.log(`ðŸ”’ Setting private scene for ${playerId} to ${sceneId}`)

            try {
                // Update DB
                await prisma.campaignPlayer.update({
                    where: {
                        campaignId_playerId: {
                            campaignId: campaignId,
                            playerId: playerId
                        }
                    },
                    data: {
                        currentPrivateSceneId: sceneId
                    }
                })

                // Notify Target Player
                const sockets = await io.in(campaignId).fetchSockets()
                const targetSocket = sockets.find(s => s.data.user.id === playerId)
                if (targetSocket) {
                    targetSocket.emit('player:private_scene_update', { sceneId })
                }

            } catch (e) {
                console.error("Error setting private scene:", e)
            }
        })

        // 2. GM: Whisper
        socket.on('gm:whisper', async (data) => {
            const { targetPlayerId, message } = data
            const campaignId = socket.data.campaignId

            if (socket.data.user.role !== 'GM' && socket.data.user.role !== 'CREATOR') return

            const sockets = await io.in(campaignId).fetchSockets()
            const targetSocket = sockets.find(s => s.data.user.id === targetPlayerId)

            if (targetSocket) {
                // Send to Target
                targetSocket.emit('player:whisper_received', {
                    sender: socket.data.user.name || "Game Master",
                    message: message
                })

                // Send Confirmation back to GM (Sender)
                socket.emit('player:whisper_received', {
                    sender: "To " + (targetSocket.data.user.name || "Player"),
                    message: message
                })
            }
        })

        // 3. GM: Set Global Scene
        socket.on('gm:set_global_scene', async (data) => {
            const { campaignId, sceneId } = data

            if (socket.data.user.role !== 'GM' && socket.data.user.role !== 'CREATOR') return

            try {
                const campaign = await prisma.campaign.findUnique({ where: { id: campaignId } })
                if (campaign) {
                    const currentState = parseJSON(campaign.currentState)
                    const newState = { ...currentState, currentScene: sceneId }

                    // 1. Update Global State
                    await prisma.campaign.update({
                        where: { id: campaignId },
                        data: { currentState: JSON.stringify(newState) }
                    })

                    // 2. Reset ALL Private Scenes for this campaign
                    await prisma.campaignPlayer.updateMany({
                        where: { campaignId: campaignId },
                        data: { currentPrivateSceneId: null }
                    })

                    // 3. Broadcast Global Update
                    io.to(campaignId).emit('game:scene_update', { sceneId })
                    // à¹à¸–à¸¡ state update à¹€à¸•à¹‡à¸¡à¹† à¹„à¸›à¸”à¹‰à¸§à¸¢ (à¹€à¸œà¸·à¹ˆà¸­ frontend à¹ƒà¸Šà¹‰à¸­à¸±à¸™à¹€à¸”à¸´à¸¡)
                    io.to(campaignId).emit('game:state_update', newState)

                    // 4. Notify everyone that their private scene is cleared
                    io.to(campaignId).emit('player:private_scene_update', { sceneId: null })
                }
            } catch (e) {
                console.error("Error setting global scene:", e)
            }
        })

        // 4. Chat System
        socket.on('chat:send', async (data, callback) => {
            const { roomId, content, type } = data
            const sender = socket.data.user

            try {
                console.log(`ðŸ’¬ Chat from ${sender.name}: ${content}`)

                const messageData = {
                    id: Date.now().toString(),
                    content,
                    type,
                    senderId: sender.id,
                    senderName: sender.name,
                    timestamp: new Date()
                }

                // Broadcast
                io.to(roomId).emit('chat:message', messageData)

                if (callback) callback({ success: true, messageId: messageData.id })

            } catch (e) {
                console.error("Chat Error:", e)
                if (callback) callback({ success: false, error: 'Failed to send message' })
            }
        })


        socket.on('disconnect', () => {
            const campaignId = socket.data.campaignId
            if (campaignId) {
                console.log(`ðŸ‘‹ User disconnected from ${campaignId}: ${socket.data.user.name}`)
                io.to(campaignId).emit('room:player_left', {
                    userId: socket.data.user.id,
                    userName: socket.data.user.name
                })
            }
        })
    })

    // à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ AI (à¹à¸šà¸š Functional à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡)
    async function processActionWithAI(io: Server, campaignId: string, action: any, user: any) {
        try {
            // 1. à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸¥à¹ˆà¸²à¸ªà¸¸à¸”
            const campaign = await prisma.campaign.findUnique({
                where: { id: campaignId }
            })
            if (!campaign) return

            // 2. à¹€à¸•à¸£à¸µà¸¢à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (à¹à¸›à¸¥à¸‡ String -> Object)
            const currentStateString = parseJSON(campaign.currentState)

            // à¹à¸›à¸¥à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸«à¹‰à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸£à¸¹à¸›à¹à¸šà¸šà¸—à¸µà¹ˆ AI à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆ (GameState Interface)
            const gameState = {
                currentScene: currentStateString.currentScene || "Unknown",
                environment: currentStateString.environment || "Unknown",
                recentEvents: currentStateString.recentEvents || [],
                characters: [] // Empty array since we don't have characters relation
            }

            // Default actor stats
            const actorStats = { strength: 10, dexterity: 10, intelligence: 10, wisdom: 10, charisma: 10, constitution: 10 }

            // 3. à¹ƒà¸«à¹‰ AI à¸„à¸´à¸” (à¹€à¸£à¸µà¸¢à¸ Function à¸•à¸£à¸‡à¹† à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡ new Class)
            const result = await processGameTurn(
                gameState,
                {
                    actionType: action.type || 'move', // Default fallback
                    actorId: user.id,
                    actorName: user.name || 'Unknown',
                    description: action.detail || action.description || 'does something',
                    skillName: action.skillName,
                    itemName: action.itemName
                },
                actorStats
            )

            // 4. à¸šà¸±à¸™à¸—à¸¶à¸à¸œà¸¥à¸¥à¸‡ DB (à¹à¸›à¸¥à¸‡ Object -> String)
            // à¸­à¸±à¸›à¹€à¸”à¸• State à¹‚à¸”à¸¢à¸£à¸§à¸¡ (Narrative)
            const newState = {
                ...currentStateString,
                recentEvents: [...(currentStateString.recentEvents || []), result.narration].slice(-5) // à¹€à¸à¹‡à¸š 5 à¹€à¸«à¸•à¸¸à¸à¸²à¸£à¸“à¹Œà¸¥à¹ˆà¸²à¸ªà¸¸à¸”
            }

            await prisma.campaign.update({
                where: { id: campaignId },
                data: { currentState: JSON.stringify(newState) }
            })

            // 5. à¸ªà¹ˆà¸‡à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¸à¸¥à¸±à¸šà¹„à¸›à¸—à¸µà¹ˆà¸«à¸™à¹‰à¸²à¸ˆà¸­
            io.to(campaignId).emit('game:state_update', newState)
            io.to(campaignId).emit('chat:message', {
                id: Date.now().toString(),
                content: result.narration,
                type: 'NARRATION',
                senderName: 'Game Master'
            })

            // à¸ªà¹ˆà¸‡à¸œà¸¥à¸¥à¸¹à¸à¹€à¸•à¹‹à¸² (à¸–à¹‰à¸²à¸¡à¸µ)
            if (result.dice_results) {
                io.to(campaignId).emit('game:dice_result', result.dice_results)
            }

        } catch (error) {
            console.error('AI Processing Error:', error)
            // à¹à¸ˆà¹‰à¸‡ Error à¸à¸¥à¸±à¸šà¹„à¸›à¸—à¸µà¹ˆ Client à¹€à¸žà¸·à¹ˆà¸­à¹„à¸¡à¹ˆà¹ƒà¸«à¹‰à¹€à¸‡à¸µà¸¢à¸šà¸«à¸²à¸¢
            io.to(campaignId).emit('chat:message', {
                id: Date.now().toString(),
                content: "The Game Master is pondering... (AI Error, falling back to manual mode)",
                type: 'NARRATION',
                senderName: 'System'
            })
        }
    }

    const PORT = process.env.PORT || 3000
    httpServer.listen(PORT, () => {
        console.log(`> Ready on http://localhost:${PORT}`)
    })
})